Index: openssl-1.0.1e/crypto/sm1/sm1.h
===================================================================
--- openssl-1.0.1e/crypto/sm1/sm1.h	(revision 9134)
+++ openssl-1.0.1e/crypto/sm1/sm1.h	(working copy)
@@ -19,7 +19,8 @@
 #define SM1_DECRYPT		0
 
 #define SM1_BLOCK_SIZE	16
-#define SM1_IV_SIZE		16
+#define SM1_KEY_SIZE	16
+#define SM1_IV_SIZE		SM1_BLOCK_SIZE
 
 #ifdef  __cplusplus
 extern "C" {
@@ -27,7 +28,8 @@
 
 	/* This should be a hidden type, but EVP requires that the size be known */
 	struct sm1_key_st {
-			void* sm1_handle;
+		u_int8_t key_data[2*SM1_BLOCK_SIZE];
+		u_int32_t key_size;
 	};
 	typedef struct sm1_key_st SM1_KEY;
 
Index: openssl-1.0.1e/crypto/sm1/sm1_core.c
===================================================================
--- openssl-1.0.1e/crypto/sm1/sm1_core.c	(revision 9134)
+++ openssl-1.0.1e/crypto/sm1/sm1_core.c	(working copy)
@@ -1,5 +1,5 @@
 /* crypto/sm1/sm1_core.c */
-/* 
+/*
  */
 
 #include <assert.h>
@@ -7,25 +7,293 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
+#include <dlfcn.h>
 #include <openssl/sm1.h>
+#include <openssl/crypto.h>
+#include <openssl/err.h>
+#include <openssl/sm/fm_def.h>
+#include <openssl/sm/fm_cpc_pub.h>
+#include <openssl/sm/sm_pub.h>
 
+//#define SM1_TEST
+
+struct gmcard_block {
+	int dev_type;
+	void *dev_handle;
+	void *open_dev;
+	void *close_dev;
+	void *enc_func;
+	void *dec_func;
+	void *get_errinfo;
+} global_sm1_key = {0, NULL, NULL, NULL, NULL, NULL, NULL};
+
+typedef unsigned int (fm_OpenDev) (
+	FM_U8 *pu8Id,
+	FM_U32 u32Type,
+	FM_U32 u32Flag,
+	FM_HANDLE *hDev
+	);
+
+typedef unsigned int (fm_CloseDev) (
+	FM_HANDLE hDev
+	);
+
+typedef unsigned int (fm_Encrypt) (
+	FM_HANDLE hDev,
+	FM_HKEY hKey,
+	FM_U32 u32Alg,
+	FM_U32 u32WorkMode,
+	FM_U8 *pu8InBuf,
+	FM_U32 u32InLen,
+	FM_U8 *pu8OutBuf,
+	FM_U32 *pu32OutLen,
+	FM_U8 *pu8Key,
+	FM_U32 u32KeyLen,
+	FM_U8 *pu8IV,
+	FM_U32 u32IVLen
+	);
+
+typedef unsigned int (fm_Decrypt) (
+	FM_HANDLE hDev,
+	FM_HKEY hKey,
+	FM_U32 u32Alg,
+	FM_U32 u32WorkMode,
+	FM_U8 *pu8InBuf,
+	FM_U32 u32InLen,
+	FM_U8 *pu8OutBuf,
+	FM_U32 *pu32OutLen,
+	FM_U8 *pu8Key,
+	FM_U32 u32KeyLen,
+	FM_U8 *pu8IV,
+	FM_U32 u32IVLen);
+
+typedef unsigned int (fm_ErrInfo) (
+    FM_U32 u32LanFlag,
+    FM_U32 u32ErrCode,
+    FM_U32 *pu32Len,
+    FM_S8 *ps8Info
+    );
+
+int Load_and_Open_fmdev(int subtype)
+{
+	void *plib = NULL;
+	FM_U32 u32Ret = FME_OK;
+	FM_U8 u8Id = 0;
+	FM_U32 dev_type;
+
+#ifdef SM1_TEST
+	printf("%s() Load dymanic lib [%s]\n", __func__, FM_API_LIB);
+#endif
+
+	/* maybe there are other types, we can get information for Fisherman */
+	switch(subtype)
+	{
+	case dev_type_pci_1_2:
+		dev_type = FM_DEV_TYPE_SJK0810;
+		break;
+	case dev_type_pci_2_0:
+		dev_type = FM_DEV_TYPE_PCI_2_0X;
+		break;
+	case dev_type_pcie_1_0:
+		dev_type = FM_DEV_TYPE_PCIE_1_0X;
+		break;
+	case dev_type_pcie_2_0:
+		dev_type = FM_DEV_TYPE_PCIE_2_0X;
+		break;
+	default:
+		CRYPTOerr(CRYPTO_F_INT_SM_CARD,CRYPTO_R_UNKNOWN_SMCARD_TYPE);
+		return -1;
+	}
+
+	plib = dlopen(FM_API_LIB, RTLD_NOW | RTLD_GLOBAL);
+	if(NULL == plib) {
+#ifdef SM1_TEST
+		printf("dlopen err\n");
+#endif
+		CRYPTOerr(CRYPTO_F_INT_SM_CARD,CRYPTO_R_LOAD_DL_FAILURE);
+		return -2;
+	}
+
+	global_sm1_key.open_dev = dlsym(plib, "FM_CPC_OpenDevice");
+	if(NULL == global_sm1_key.open_dev) {
+#ifdef SM1_TEST
+		printf("get open_dev err\n");
+#endif
+		CRYPTOerr(CRYPTO_F_INT_SM_CARD,CRYPTO_R_LOAD_SYM_FAILURE);
+		return -3;
+	}
+
+	global_sm1_key.close_dev = dlsym(plib, "FM_CPC_CloseDevice");
+	if(NULL == global_sm1_key.close_dev) {
+#ifdef SM1_TEST
+		printf("get close_dev err\n");
+#endif
+		CRYPTOerr(CRYPTO_F_INT_SM_CARD,CRYPTO_R_LOAD_SYM_FAILURE);
+		return -3;
+	}
+
+	global_sm1_key.enc_func = dlsym(plib, "FM_CPC_Encrypt");
+	if(NULL == global_sm1_key.enc_func) {
+#ifdef SM1_TEST
+		printf("get enc_func err\n");
+#endif
+		CRYPTOerr(CRYPTO_F_INT_SM_CARD,CRYPTO_R_LOAD_SYM_FAILURE);
+		return -3;
+	}
+
+	global_sm1_key.dec_func = dlsym(plib, "FM_CPC_Decrypt");
+	if(NULL == global_sm1_key.dec_func) {
+#ifdef SM1_TEST
+		printf("get dec_func err\n");
+#endif
+		CRYPTOerr(CRYPTO_F_INT_SM_CARD,CRYPTO_R_LOAD_SYM_FAILURE);
+		return -3;
+	}
+
+	global_sm1_key.get_errinfo = dlsym(plib, "FM_CPC_GetErrInfo");
+	if(NULL == global_sm1_key.get_errinfo) {
+#ifdef SM1_TEST
+		printf("get get_errinfo err\n");
+#endif
+		CRYPTOerr(CRYPTO_F_INT_SM_CARD,CRYPTO_R_LOAD_SYM_FAILURE);
+		return -3;
+	}
+
+	/* open device */
+	u32Ret = ((fm_OpenDev *)(global_sm1_key.open_dev))(&u8Id, dev_type,
+				(FM_OPEN_MULTITHREAD | FM_OPEN_MULTIPROCESS),
+				&(global_sm1_key.dev_handle));
+	if (FME_OK != u32Ret)
+	{
+#ifdef SM1_TEST
+		FM_U32 len = 128;
+		FM_S8 aBuf[128];
+		((fm_ErrInfo *)(global_sm1_key.get_errinfo))(1, u32Ret, &len, aBuf);
+		printf("Open PCI Card failed: %s\n", aBuf);
+#endif
+		CRYPTOerr(CRYPTO_F_INT_SM_CARD,CRYPTO_R_OPEN_DEV_FAILURE);
+		return -4;
+	}
+
+	global_sm1_key.dev_type = vendor_fm;
+	return 0;
+}
+
 int SM1_set_encrypt_key(const unsigned char *userKey, const int bits,
 	SM1_KEY *key)
 {
-//	printf("SM1_set_encrypt_key\n");
+	static int key_inited = 0;
+
+	/* init struct SM1_KEY if necessary */
+	if(!key_inited) {
+		int vendor = 0, subtype = 0;
+
+		if (get_smcard_info(&vendor, &subtype)) {
+			CRYPTOerr(CRYPTO_F_INT_SM_CARD,CRYPTO_R_GET_SMCARD_TYPE);
+			return -1;
+		}
+		switch(vendor)
+		{
+		case vendor_fm:
+			if(Load_and_Open_fmdev(subtype))
+				return -1;
+			break;
+		default:
+			break;
+		}
+
+		key_inited = 1;
+	}
+
+	memset(key, 0, sizeof(*key));
+	/* restore key */
+	key->key_size = bits>>3;
+	memcpy(key->key_data, userKey, key->key_size);
+
 	return 0;
 }
+
 int SM1_set_decrypt_key(const unsigned char *userKey, const int bits,
 	SM1_KEY *key)
 {
-//	printf("SM1_set_decrypt_key\n");
-	return 0;
+	return SM1_set_encrypt_key(userKey, bits, key);
 }
 
 void SM1_cbc_encrypt(const unsigned char *in, unsigned char *out,
     size_t length, const SM1_KEY *key,
     unsigned char *ivec, const int enc)
 {
-	memmove(out, in, length);
-//	printf("SM1_cbc_encrypt\n");
+	FM_U32 u32Ret = FME_OK;
+	FM_U32 outLen = 0;
+	u_int8_t *outData = NULL;
+
+	if(!global_sm1_key.dev_handle) {
+#ifdef SM1_TEST
+		printf("handle is null\n");
+#endif
+		goto end;
+	}
+
+	outData = OPENSSL_malloc(length*sizeof(u_int8_t));
+	if(!outData)
+	{
+		printf("%s() malloc failed\n", __func__);
+		goto end;
+	}
+
+	if(enc) {
+		if(NULL == global_sm1_key.enc_func)
+		{
+#ifdef SM1_TEST
+			printf("Encrypt function point is null\n");
+#endif
+			goto end;
+		}
+
+		u32Ret = ((fm_Encrypt *)(global_sm1_key.enc_func))(global_sm1_key.dev_handle,
+								FM_HKEY_FROM_HOST,  FM_ALG_SM1, FM_ALGMODE_CBC,
+								(FM_U8 *)in, length, outData, &outLen,
+								(FM_U8 *)key->key_data, key->key_size,
+								ivec, SM1_IV_SIZE);
+		if (FME_OK != u32Ret)
+		{
+#ifdef SM1_TEST
+			FM_U32 len = 0;
+			FM_S8 aBuf[128];
+			((fm_ErrInfo *)(global_sm1_key.get_errinfo))(1, u32Ret, &len, aBuf);
+			printf("FM_CPC_Encrypt failed [%s]\n", aBuf);
+#endif
+			goto end;
+		}
+	}
+	else {
+		if(NULL == global_sm1_key.dec_func)
+		{
+#ifdef SM1_TEST
+			printf("Decrypt function point is null\n");
+#endif
+			goto end;
+		}
+		u32Ret = ((fm_Decrypt *)(global_sm1_key.dec_func))(global_sm1_key.dev_handle,
+								FM_HKEY_FROM_HOST,  FM_ALG_SM1, FM_ALGMODE_CBC,
+								(FM_U8 *)in, length, outData, &outLen,
+								(FM_U8 *)key->key_data, key->key_size,
+								ivec, SM1_IV_SIZE);
+		if (FME_OK != u32Ret)
+		{
+#ifdef SM1_TEST
+			FM_U32 len = 0;
+			FM_S8 aBuf[128];
+			((fm_ErrInfo *)(global_sm1_key.get_errinfo))(1, u32Ret, &len, aBuf);
+			printf("FM_CPC_Decrypt failed [%s]\n", aBuf);
+#endif
+			goto end;
+		}
+	}
+	memcpy(out, outData, outLen);
+
+end:
+	if(outData)
+		OPENSSL_free(outData);
+	return;
 }
Index: openssl-1.0.1e/include/openssl/sm/fm_cpc_pub.h
===================================================================
--- openssl-1.0.1e/include/openssl/sm/fm_cpc_pub.h	(revision 0)
+++ openssl-1.0.1e/include/openssl/sm/fm_cpc_pub.h	(revision 0)
@@ -0,0 +1,744 @@
+/******************************************************************************
+* Copyright (c) 2008, Shandong Fisherman Information Technology Co., Ltd. 
+* All rights reserved.
+* 文件名称: fm_cpc_pub.h
+* 文件描述: Fisherman 加密设备(Crypto PCI Card, CPC)公共函数接口
+* 当前版本: 1.0
+* 作    者: 
+* 创建时间: 2008-08-21 
+* 修改记录: 
+* ----------------------------------------------
+*    时间    作者     描述
+******************************************************************************/
+#ifndef FM_CPC_PUB_H
+#define FM_CPC_PUB_H
+
+#ifdef  __cplusplus
+    extern "C" {
+#endif
+
+// open card dev type，now replace FM_DEV_TYPE_SJK0809、FM_DEV_TYPE_SJK0810
+#define FM_DEV_TYPE_PCI_1_2X      0x0120    //pci  V1.2  if use FM_DEV_TYPE_SJK0810, also means use this
+#define FM_DEV_TYPE_PCI_2_0X      0x0200    //pci  V2.0
+#define FM_DEV_TYPE_PCIE_1_0X     0xE100    //pcie V1.0
+#define FM_DEV_TYPE_PCIE_2_0X     0xE200    //pcie V2.0  if use FM_DEV_TYPE_SJK0809, also means use this
+
+/************************ 用户管理 ************************/
+// 用户身份
+#define CPC_USER_ADMIN          1   /* 管理员 */
+#define CPC_USER_OPER           2   /* 操作员 */
+// 用户数目
+#define CPC_USER_MAXADMIN       5   /* 最多管理员数目 */
+#define CPC_USER_MAXOPER        5   /* 最多操作员数目 */
+#define CPC_USER_MAXUSER        (CPC_USER_MAXADMIN + CPC_USER_MAXOPER) /* 最多用户数 */
+// 用户管理
+#define CPC_USER_ADDADMIN       1   /* 添加管理员 */
+#define CPC_USER_ADDOPER        2   /* 添加操作员 */
+#define CPC_USER_DELADMIN       3   /* 删除管理员 */
+#define CPC_USER_DELOPER        4   /* 删除操作员 */
+// 用户备份管理
+#define CPC_USER_BAK            1   /* 备份 */
+#define CPC_USER_RES            2   /* 恢复 */
+#define CPC_USER_BAKINIT        3   /* 备份初始化 */
+#define CPC_USER_RESINIT        4   /* 恢复初始化 */
+// 认证状态
+#define CPC_USER_AUTHPASS       1   /* 认证通过 */
+#define CPC_USER_AUTHNOPASS     0   /* 认证未通过 */
+
+typedef struct tagUserInfoSt
+{
+    FM_U8 au8Serial[FM_DEVINFO_SERIAL_LEN];     // 序列号
+    FM_U8 u8Flag;                               // 本卡身份 CPC_USER_ADMIN / CPC_USER_OPER */
+    FM_U8 u8IsAuthed;                           // 是否登录     1已登录
+    FM_U8 u8Reserve1;                           // 保留
+    FM_U8 u8Reserve2;                           // 保留
+}CPC_USER_INFO, *PCPC_USER_INFO;
+
+/****************************备份需要的公开结构********************************/
+// 备份类型
+#define CPC_BK_TYPE_ALL     1   // 备份所有内容
+#define CPC_BK_TYPE_FILEALL 2   // 备份文件系统 暂不支持
+#define CPC_BK_TYPE_FILE    3   // 备份单个文件 暂不支持
+#define CPC_BK_TYPE_WKALL   4   // 备份所有工作密钥
+#define CPC_BK_TYPE_WK      5   // 备份单个工作密钥
+#define CPC_BK_TYPE_RSAALL  6   // 备份所有RSA密钥
+#define CPC_BK_TYPE_RSA     7   // 备份单个RSA密钥
+
+// 备份信息存储的设备类型
+#define CPC_BK_STORE_HOST   1    // 备份信息存储在主机文件
+#define CPC_BK_STORE_DEVKEY 2    // 备份信息存储在设备所属的IC卡或者USBKey 暂不支持
+
+// 备份管理初始化时的配置结构
+typedef struct stBkConifg
+{
+    FM_U32      u32Type;                // 备份类型
+    FM_U32      u32StoreDev;            // 备份信息存储的设备类型
+    FM_U8       u8StoreFile[128];       // 备份信息存储的文件名
+    FM_U32      u32ThresholdKeyID;      // 设备所属的IC卡或者USBKey中门限备份的密钥ID [0-99]
+    
+    // u32Type为CPC_BK_TYPE_WK/CPC_BK_TYPE_RSA时有效
+    // 备份初始化(CPC_BK_MNGOP_BAKINIT)时，此参数表示备份的密钥ID
+    // 恢复初始化(CPC_BK_MNGOP_RESINIT)时，此参数表示恢复到此指定密钥ID。等于全F时
+    // 表示使用备份时的ID作为恢复的密钥ID
+    FM_U32	    u32HKey;
+    
+    FM_U8       u8FullPath[128];    // u32Type为CPC_BK_TYPE_FILE时有效, 备份的单个文件的全路径  
+    FM_U32      u32Resvered[16];    // 保留为0
+} CPC_BK_CONFIG, *PCPC_BK_CONFIG;
+
+
+
+/****************************** API 函数定义 *********************************/
+FM_RET FM_CPC_OpenDevice
+(
+    FM_I FM_U8     *pu8Id,
+    FM_I FM_U32     u32Type,
+    FM_I FM_U32     u32Flag,
+    FM_O FM_HANDLE *phDev
+);
+FM_RET FM_CPC_CloseDevice
+(
+    FM_I FM_HANDLE  hDev
+);
+FM_RET FM_CPC_GetDeviceInfo
+(
+    FM_I FM_HANDLE  hDev,
+    FM_O FM_DEV_INFO  *pDevInfo
+); 
+FM_RET FM_CPC_GenRandom
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Len,
+    FM_O FM_U8     *pu8Random
+);
+FM_RET FM_CPC_GetInfo
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Flag,
+    FM_I FM_U32     u32InLen,
+    FM_I FM_U8     *pu8InBuf,
+    FM_B FM_U32    *pu32Len,
+    FM_O FM_U8     *pu8OutBuf
+);
+FM_RET FM_CPC_GetErrInfo
+(
+    FM_I FM_U32     u32LanFlag,
+    FM_I FM_U32     u32ErrCode,
+    FM_B FM_U32    *pu32Len,
+    FM_O FM_S8     *ps8Info
+);
+FM_RET FM_CPC_GenRSAKeypair
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32KeyBits,
+    FM_B FM_HKEY   *phKey,
+    FM_O FM_RSA_PublicKey  *pPubkey, 
+    FM_O FM_RSA_PrivateKey *pPrikey 
+);
+FM_RET FM_CPC_DelRSAKeypair
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_HKEY    hKey
+);
+FM_RET FM_CPC_ImportRSAKeypair
+(
+    FM_I FM_HANDLE  hDev,
+    FM_B FM_HKEY   *phKey,
+    FM_I FM_RSA_PublicKey  *pPubkey,
+    FM_I FM_RSA_PrivateKey *pPrikey
+);
+FM_RET FM_CPC_ExportRSAKeypair
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_HKEY    hKey,
+    FM_O FM_RSA_PublicKey  *pPubkey,
+    FM_O FM_RSA_PrivateKey *pPrikey
+);
+FM_RET FM_CPC_RSAEncrypt
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_HKEY    hKey,
+    FM_I FM_U8     *pu8InBuf,
+    FM_I FM_U32     u32InLen,
+    FM_O FM_U8     *pu8OutBuf,
+    FM_O FM_U32    *pu32OutLen,
+    FM_I FM_RSA_PublicKey *pPubkey
+);
+FM_RET FM_CPC_RSADecrypt
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_HKEY    hKey,
+    FM_I FM_U8     *pu8InBuf,
+    FM_I FM_U32     u32InLen,
+    FM_O FM_U8     *pu8OutBuf,
+    FM_O FM_U32    *pu32OutLen,
+    FM_I FM_RSA_PrivateKey *pPrikey
+);
+FM_RET FM_CPC_RSASign
+(
+	FM_I	FM_HANDLE	hDev,
+	FM_I	FM_HKEY		hKey,
+	FM_I	FM_U32		u32Alg,
+	FM_I	FM_U8		*pu8DataBuf,
+	FM_I	FM_U32		u32DataLen,
+	FM_O	FM_U8		*pu8SignBuf,
+	FM_O 	FM_U32		*pu32SignLen,
+	FM_I 	FM_RSA_PrivateKey  *pPrikey
+);
+FM_RET FM_CPC_RSAVerify
+(
+	FM_I	FM_HANDLE	hDev,
+	FM_I	FM_HKEY		hKey,
+	FM_I	FM_U32		u32Alg,
+	FM_I	FM_U8		*pu8DataBuf,
+	FM_I	FM_U32		u32DataLen,
+	FM_I	FM_U8		*pu8SignBuf,
+	FM_I	FM_U32		u32SignLen,
+	FM_I	FM_RSA_PublicKey   *pPubkey
+);
+FM_RET FM_CPC_GenECCKeypair
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Alg,
+    FM_B FM_HKEY   *phKey,
+    FM_O FM_ECC_PublicKey  *pPubkey, 
+    FM_O FM_ECC_PrivateKey *pPrikey 
+);
+FM_RET FM_CPC_DelECCKeypair
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_HKEY    hKey
+);
+FM_RET FM_CPC_ImportECCKeypair
+(
+    FM_I FM_HANDLE  hDev,
+    FM_B FM_HKEY   *phKey,
+    FM_I FM_ECC_PublicKey  *pPubkey,
+    FM_I FM_ECC_PrivateKey *pPrikey
+);
+FM_RET FM_CPC_ExportECCKeypair
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_HKEY    hKey,
+    FM_O FM_ECC_PublicKey  *pPubkey,
+    FM_O FM_ECC_PrivateKey *pPrikey
+);
+FM_RET FM_CPC_ECCEncrypt
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Alg,
+    FM_I FM_HKEY    hKey,
+    FM_I FM_U8     *pu8InBuf,
+    FM_I FM_U32     u32InLen,
+    FM_I FM_ECC_PublicKey *pPubkey,
+    FM_O FM_ECC_Cipher    *pECCCipher
+);
+FM_RET FM_CPC_ECCDecrypt
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Alg,
+    FM_I FM_HKEY    hKey,
+    FM_I FM_ECC_Cipher     *pECCCipher,
+    FM_I FM_ECC_PrivateKey *pPrikey,
+    FM_O FM_U8     *pu8OutBuf,
+    FM_O FM_U32    *pu32OutLen
+);
+FM_RET FM_CPC_ECCSign
+(
+    FM_I FM_HANDLE             hDev,
+    FM_I FM_U32                u32Alg,
+    FM_I FM_HKEY               hKey,
+    FM_I FM_U8                *pu8InBuf,
+    FM_I FM_U32                u32InLen,
+    FM_I FM_ECC_PrivateKey    *pPrikey,
+    FM_O FM_ECC_Signature     *pSignature
+);
+FM_RET FM_CPC_ECCVerify
+(
+    FM_I FM_HANDLE         hDev,
+    FM_I FM_U32            u32Alg,
+    FM_I FM_HKEY           hKey,
+    FM_I FM_ECC_PublicKey *pPubkey,
+    FM_I FM_U8            *pu8InBuf,
+    FM_I FM_U32            u32InLen,
+    FM_I FM_ECC_Signature *pSignature
+);
+FM_RET FM_CPC_GenerateAgreementDataWithECC
+(
+    FM_I FM_HANDLE         hDev,
+    FM_I FM_U32            u32Alg,
+    FM_I FM_HKEY           hKey,
+    FM_I FM_U32            u32KeyBits,
+    FM_I FM_U8            *pu8SponsorID,
+    FM_I FM_U32            u32SponsorIDLen,
+    FM_O FM_ECC_PublicKey *pSponsorPubKey,
+    FM_O FM_ECC_PublicKey *pSponsorTmpPubKey,
+    FM_O FM_HANDLE        *phAgreementHandle
+);
+FM_RET FM_CPC_GenerateAgreementDataAndKeyWithECC
+(
+    FM_I FM_HANDLE         hDev,
+    FM_I FM_U32            u32Alg,
+    FM_I FM_HKEY           hKey,
+    FM_I FM_U32            u32KeyBits,
+    FM_I FM_U8            *pu8ResponseID,
+    FM_I FM_U32            u32ResponseIDLen,
+    FM_I FM_U8            *pu8SponsorID,
+    FM_I FM_U32            u32SponsorIDLen,
+    FM_I FM_ECC_PublicKey *pSponsorPubKey,
+    FM_I FM_ECC_PublicKey *pSponsorTmpPubKey,
+    FM_O FM_ECC_PublicKey *pResponsePubKey,
+    FM_O FM_ECC_PublicKey *pResponseTmpPubKey,
+    FM_O FM_HKEY          *phKeyHandle
+);
+FM_RET FM_CPC_GenerateKeyWithECC
+(
+    FM_I FM_HANDLE         hDev,
+    FM_I FM_U32            u32Alg,
+    FM_I FM_U8            *pu8ResponseID,
+    FM_I FM_U32            u32ResponseIDLen,
+    FM_I FM_ECC_PublicKey *pResponsePubKey,
+    FM_I FM_ECC_PublicKey *pResponseTmpPubKey,
+    FM_I FM_HANDLE        *phAgreementHandle,
+    FM_O FM_HKEY          *phKeyHandle
+);
+
+FM_RET FM_CPC_GenKey
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Alg,
+    FM_I FM_U32     u32InLen,
+    FM_B FM_HKEY   *phKey,
+    FM_O FM_U8     *pu8Key
+);
+FM_RET FM_CPC_DelKey
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_HKEY    hKey
+);
+FM_RET FM_CPC_ImportKey
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Alg,
+    FM_I FM_U8     *pu8Key,
+    FM_I FM_U32     u32KeyLen,
+    FM_B FM_HKEY   *phKey
+);
+FM_RET FM_CPC_ExportKey
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_HKEY    hKey,
+    FM_O FM_U8     *pu8Key,
+    FM_B FM_U32    *pu32Len
+);
+FM_RET FM_CPC_EncryptInit
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_HKEY    hKey,
+    FM_I FM_U32     u32Alg,
+    FM_I FM_U32     u32WorkMode,
+    FM_I FM_U8     *pu8Key,
+    FM_I FM_U32     u32KeyLen,
+    FM_I FM_U8     *pu8IV,
+    FM_I FM_U32     u32IVLen
+);
+FM_RET FM_CPC_EncryptUpdate
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Alg,
+    FM_I FM_U8     *pu8InBuf,
+    FM_I FM_U32     u32InLen,
+    FM_O FM_U8     *pu8OutBuf,
+    FM_O FM_U32    *pu32OutLen
+);
+FM_RET FM_CPC_EncryptFinal
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Alg
+);
+FM_RET FM_CPC_Encrypt
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_HKEY    hKey,
+    FM_I FM_U32     u32Alg,
+    FM_I FM_U32     u32WorkMode,
+    FM_I FM_U8     *pu8InBuf,
+    FM_I FM_U32     u32InLen,
+    FM_O FM_U8     *pu8OutBuf,
+    FM_O FM_U32    *pu32OutLen,
+    FM_I FM_U8     *pu8Key,
+    FM_I FM_U32     u32KeyLen,
+    FM_I FM_U8     *pu8IV,
+    FM_I FM_U32     u32IVLen
+);
+FM_RET FM_CPC_DecryptInit
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_HKEY    hKey,
+    FM_I FM_U32     u32Alg,
+    FM_I FM_U32     u32WorkMode,
+    FM_I FM_U8     *pu8Key,
+    FM_I FM_U32     u32KeyLen,
+    FM_I FM_U8     *pu8IV,
+    FM_I FM_U32     u32IVLen
+);
+FM_RET FM_CPC_DecryptUpdate
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Alg,
+    FM_I FM_U8     *pu8InBuf,
+    FM_I FM_U32     u32InLen,
+    FM_O FM_U8     *pu8OutBuf,
+    FM_O FM_U32    *pu32OutLen
+);
+FM_RET FM_CPC_DecryptFinal
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Alg
+);
+FM_RET FM_CPC_Decrypt
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_HKEY    hKey,
+    FM_I FM_U32     u32Alg,
+    FM_I FM_U32     u32WorkMode,
+    FM_I FM_U8     *pu8InBuf,
+    FM_I FM_U32     u32InLen,
+    FM_O FM_U8     *pu8OutBuf,
+    FM_O FM_U32    *pu32OutLen,
+    FM_I FM_U8     *pu8Key,
+    FM_I FM_U32     u32KeyLen,
+    FM_I FM_U8     *pu8IV,
+    FM_I FM_U32     u32IVLen
+);
+#ifdef FMCFG_OS_LINUX
+FM_RET FM_CPC_EncryptEx
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_HKEY    hKey,
+    FM_I FM_U32     u32Alg,
+    FM_I FM_U32     u32WorkMode,
+    FM_I FM_U8     *pu8InBuf,
+    FM_I FM_U32     u32InLen,
+    FM_O FM_U8     *pu8OutBuf,
+    FM_O FM_U32    *pu32OutLen,
+    FM_I FM_U8     *pu8Key,
+    FM_I FM_U32     u32KeyLen,
+    FM_I FM_U8     *pu8IV,
+    FM_I FM_U32     u32IVLen
+);
+FM_RET FM_CPC_DecryptEx
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_HKEY    hKey,
+    FM_I FM_U32     u32Alg,
+    FM_I FM_U32     u32WorkMode,
+    FM_I FM_U8     *pu8InBuf,
+    FM_I FM_U32     u32InLen,
+    FM_O FM_U8     *pu8OutBuf,
+    FM_O FM_U32    *pu32OutLen,
+    FM_I FM_U8     *pu8Key,
+    FM_I FM_U32     u32KeyLen,
+    FM_I FM_U8     *pu8IV,
+    FM_I FM_U32     u32IVLen
+);
+#endif
+FM_RET FM_CPC_HashInit
+(
+    FM_I FM_HANDLE         hDev,
+    FM_I FM_U32            u32Alg   
+);
+FM_RET FM_CPC_HashUpdate
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Alg,
+    FM_I FM_U8     *pu8InBuf,
+    FM_I FM_U32     u32InLen
+);
+FM_RET FM_CPC_HashFinal
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Alg,
+    FM_O FM_U8     *pu8OutMACBuf,
+    FM_B FM_U32    *pu32OutMACLen
+);
+#ifdef FMCFG_OS_LINUX
+FM_RET FM_CPC_HashInitEx
+(
+    FM_I FM_HANDLE              hDev, 
+    FM_I FM_U32                 u32Alg,
+    FM_O PFM_CPC_SHA1_CTX       pSHACtx
+ );
+FM_RET FM_CPC_HashUpdateEx
+(
+    FM_I FM_HANDLE              hDev,
+    FM_I FM_U32                 u32Alg,
+    FM_I FM_U8                 *pu8InBuf,
+    FM_I FM_U32                 u32InLen,
+    FM_B PFM_CPC_SHA1_CTX       pSHACtx
+);
+FM_RET FM_CPC_HashFinalEx
+(
+    FM_I FM_HANDLE              hDev,
+    FM_I FM_U32                 u32Alg,
+    FM_O FM_U8                 *pu8HashBuf,
+    FM_B FM_U32                *pu32HashLen,
+    FM_B PFM_CPC_SHA1_CTX       pSHACtx
+);
+#endif
+FM_U32 FM_CPC_SM3Init
+(
+    FM_I FM_HANDLE         hDev,
+    FM_I FM_ECC_PublicKey *pPubkey,
+    FM_I FM_U8            *pu8ID,
+    FM_I FM_U32            u32IDLen
+);
+FM_U32 FM_CPC_SM3Update
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U8     *pu8InBuf,
+    FM_I FM_U32     u32InLen
+);
+FM_U32 FM_CPC_SM3Final
+(
+    FM_I FM_HANDLE  hDev,
+    FM_O FM_U8     *pu8HashBuf,
+    FM_B FM_U32    *pu32HashLen
+);
+#ifdef FMCFG_OS_LINUX
+FM_RET FM_CPC_SM3InitEx
+(
+    FM_I FM_HANDLE               hDev,
+    FM_I FM_ECC_PublicKey       *pPubkey,
+    FM_I FM_U8                  *pu8ID,
+    FM_I FM_U32                  u32IDLen,
+    FM_O PFM_CPC_SM3_CTX         pSM3Ctx
+);
+FM_RET FM_CPC_SM3UpdateEx
+(
+    FM_I FM_HANDLE              hDev,
+    FM_I FM_U8                 *pu8InBuf,
+    FM_I FM_U32                 u32InLen,
+    FM_B PFM_CPC_SM3_CTX        pSM3Ctx
+);
+FM_RET FM_CPC_SM3FinalEx
+(
+    FM_I FM_HANDLE              hDev,
+    FM_O FM_U8                 *pu8HashBuf,
+    FM_O FM_U32                *pu32HashLen,
+    FM_I PFM_CPC_SM3_CTX        pSM3Ctx
+);
+#endif
+FM_RET FM_CPC_USER_Login
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Type,
+    FM_I FM_U8     *pu8PinBuf,
+    FM_I FM_U32     u32PinLen,
+    FM_O FM_HUSER  *phUser,
+    FM_O FM_U32    *pu32RetryNum
+);
+FM_RET FM_CPC_USER_Logout
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_HUSER   hUser
+);
+FM_RET FM_CPC_USER_ChangePin
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Flag,
+    FM_I FM_U8     *pu8OldPinBuf,
+    FM_I FM_U32     u32OldPinLen,
+    FM_I FM_U8     *pu8NewPinBuf,
+    FM_I FM_U32     u32NewPinLen,
+    FM_O FM_U32    *pu32RetryNum
+);
+FM_RET FM_CPC_USER_GetInfo
+(
+    FM_I FM_HANDLE  hDev,
+    FM_O CPC_USER_INFO aUserInfo[CPC_USER_MAXUSER]
+);
+FM_RET FM_CPC_USER_UserMng
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Flag,
+    FM_I FM_U8     *pu8Buf,
+    FM_I FM_U32     u32Len
+);
+FM_RET FM_CPC_USER_BackupMng
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Flag,
+    FM_I CPC_BK_CONFIG  *pstBkConfig,
+    FM_O FM_U32    *pu32UserAllNum,
+    FM_O FM_U32    *pu32UserDealNum
+);
+
+FM_RET FM_CPC_FILE_Init
+(
+    FM_I FM_HANDLE  hDev
+);
+FM_RET FM_CPC_FILE_CreateDir
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_S8     *ps8FullDir,
+    FM_I FM_U32     u32AccCond
+);
+FM_RET FM_CPC_FILE_DeleteDir
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_S8     *ps8FullDir
+);
+FM_RET FM_CPC_FILE_CreateFile
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_S8     *ps8DirName,
+    FM_I FM_S8     *ps8FileName,
+    FM_I FM_U32     u32FileSize,
+    FM_I FM_U32     u32AccCond
+);
+FM_RET FM_CPC_FILE_ReadFile
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_S8     *ps8DirName,
+    FM_I FM_S8     *ps8FileName,
+    FM_I FM_U32     u32Offset,
+    FM_I FM_U32     u32Size,
+    FM_O FM_U8     *pu8Buf
+);
+FM_RET FM_CPC_FILE_WriteFile
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_S8     *ps8DirName,
+    FM_I FM_S8     *ps8FileName,
+    FM_I FM_U32     u32Offset,
+    FM_I FM_U32     u32Size,
+    FM_I FM_U8     *pu8Buf
+);
+FM_RET FM_CPC_FILE_DeleteFile
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_S8     *ps8DirName,
+    FM_I FM_S8     *ps8FileName
+);
+FM_RET FM_CPC_FILE_EnmuDir
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_S8     *ps8DirName,
+    FM_B FM_U32    *pu32BufLen,
+    FM_O FM_U8     *pu8Buf,
+    FM_O FM_U32    *pu32DirNum
+);
+FM_RET FM_CPC_FILE_EnmuFile
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_S8     *ps8DirName,
+    FM_B FM_U32    *pu32BufLen,
+    FM_O FM_U8     *pu8Buf,
+    FM_O FM_U32    *pu32FileNum
+);
+FM_RET FM_CPC_Cmd
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U32     u32Cmd, 
+    FM_I FM_U32     aPara[],
+    FM_I FM_U8     *pu8InData,
+    FM_I FM_U32     u32InLen, 
+    FM_O FM_U8     *pu8OutData, 
+    FM_B FM_U32    *pu32OutLen
+);
+//生成设备主密钥
+FM_RET CPC_Master_GenKey
+(
+    FM_I FM_HANDLE  hDev
+);
+//导入设备主密钥
+FM_RET CPC_Master_ImportKey
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U8     *pu8Key,
+    FM_I FM_U32     u32KeyLen
+);
+//导出设备主密钥
+FM_RET CPC_Master_ExportKey
+(
+    FM_I FM_HANDLE  hDev,
+    FM_O FM_U8     *pu8Key,
+    FM_O FM_U32    *pu32Len
+);
+//主密钥进行加密
+FM_RET CPC_Master_Encrypt
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U8     *pu8InBuf,
+    FM_I FM_U32     u32InLen,
+    FM_O FM_U8     *pu8OutBuf,
+    FM_O FM_U32    *pu32OutLen
+);
+//主密钥进行解密
+FM_RET CPC_Master_Decrypt
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U8     *pu8InBuf,
+    FM_I FM_U32     u32InLen,
+    FM_O FM_U8     *pu8OutBuf,
+    FM_O FM_U32    *pu32OutLen
+);
+//key中密钥进行加密
+FM_RET CPC_Usbkey_Encrypt
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U8     *pu8InBuf,
+    FM_I FM_U32     u32InLen,
+    FM_O FM_U8     *pu8OutBuf,
+    FM_O FM_U32    *pu32OutLen
+);
+//key中密钥进行解密
+FM_RET CPC_Usbkey_Decrypt
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U8     *pu8InBuf,
+    FM_I FM_U32     u32InLen,
+    FM_O FM_U8     *pu8OutBuf,
+    FM_O FM_U32    *pu32OutLen
+);
+FM_RET FM_CPC_USER_Right
+(
+    FM_I FM_HANDLE  hDev,
+    FM_I FM_U8  *pu8serial,
+    FM_I FM_U32  u32Len
+);
+FM_RET FM_CPC_ContainerWrite
+(
+	FM_I FM_HANDLE  hDev,
+	FM_I FM_U32  	u32Flag,
+	FM_I FM_U8  	*pContainerName,
+	FM_I FM_U8  	*pCert,
+	FM_I FM_U32  	u32CertLen
+);
+FM_RET FM_CPC_ContainerRead
+(
+	FM_I FM_HANDLE  hDev,
+	FM_I FM_U32  	u32Flag,	
+	FM_I FM_U8  	*pContainerName,
+	FM_O FM_U8  	*pValue,
+	FM_O FM_U32  	*pu32ValueLen
+);
+FM_RET FM_CPC_ContainerDelete
+(
+	FM_I FM_HANDLE  hDev,
+	FM_I FM_U8  	*pContainerName
+);
+FM_RET FM_CPC_ContainerEnum
+(
+	FM_I FM_HANDLE  hDev,
+	FM_O FM_U8  	*pContainerNames,
+	FM_O FM_U32  	*pu32ContainerCount
+);
+
+#ifdef  __cplusplus
+    }
+#endif  /* #ifdef  __cplusplus */
+
+#endif  /* #ifndef FM_CPC_PUB_H */
+

Property changes on: openssl-1.0.1e/include/openssl/sm/fm_cpc_pub.h
___________________________________________________________________
Added: svn:executable
   + *

Index: openssl-1.0.1e/include/openssl/sm/fm_def.h
===================================================================
--- openssl-1.0.1e/include/openssl/sm/fm_def.h	(revision 0)
+++ openssl-1.0.1e/include/openssl/sm/fm_def.h	(revision 0)
@@ -0,0 +1,461 @@
+/******************************************************************************
+* Copyright (c) 2008, Shandong Fisherman Information Technology Co., Ltd. 
+* All rights reserved.
+* 文件名称: fm_def.h
+* 文件描述: 渔翁公共定义头文件。
+* 当前版本: 1.0
+* 作    者: 
+* 创建时间: 2008-08-21
+* 修改记录: 
+* ----------------------------------------------
+*    时间    作者     描述
+******************************************************************************/
+#ifndef FM_DEF_H
+#define FM_DEF_H
+
+#ifndef FMCFG_OS_LINUX
+#define FMCFG_OS_LINUX
+#endif
+
+#ifdef  __cplusplus
+    extern "C" {
+#endif
+
+#define FM_LITTLE_ENDIAN
+//#define FM_BIG_ENDIAN
+
+/*********************** basic data type ************************/
+#define FM_S8               char
+#define FM_U8               unsigned char
+#define FM_S16              short int
+#define FM_U16              unsigned short int
+#define FM_S32              int
+#define FM_U32              unsigned int
+#define FM_S64              long  	   /* only used in 64b os */
+#define FM_U64              unsigned long  /* only used in 64b os */
+#define FM_UP               unsigned long  /* sizeof(FM_UP)==sizeof(pointer) */
+#define FM_F32              float
+#define FM_F64              double
+#define FM_VOID             void 
+#define FM_HANDLE           void *
+#define FM_HKEY             void *
+#define FM_HUSER            void *
+#define FM_BOOL             unsigned int
+
+#define FM_NULL             ((void *) 0)
+#define FM_TRUE             1
+#define FM_FALSE            0
+#define FM_U8_INVALID       0xff
+#define FM_U16_INVALID      0xffff
+#define FM_U32_INVALID      0xffffffff
+#define FM_HANDLE_INVALID   (FM_HANDLE)(-1)
+#define FM_C                const
+
+#ifdef FM_WINDLL
+    #define    FM_RET  FM_U32 _stdcall
+    #define    FM_DLLCALL     _stdcall
+#else
+    #define    FM_RET  FM_U32
+    #define    FM_DLLCALL 
+#endif
+
+/*************** function parameter description  ****************/
+#define FM_I    /* input  parameter */
+#define FM_O    /* output parameter */
+#define FM_B    /* both input and output parameter */
+
+/********************* language identifier **********************/
+#define FM_LAN_CN               0      /* chinese */
+#define FM_LAN_EN               1      /* english */
+
+/************************ algorithm mode ************************/
+#define FM_ALGMODE_ECB          0x00000000
+#define FM_ALGMODE_CBC          0x00000001
+#define FM_ALGMODE_CFB          0x00000002
+#define FM_ALGMODE_OFB          0x00000003
+#define FM_ALGMODE_MAC          0x00000004
+#define FM_ALGMODE_CTR          0x00000005
+/********************* algorithm identifier *********************/
+/* get alg mask */
+#define FM_ALG_GETMASK(alg) (1 << ((alg) % 32))
+/* symmetry */
+#define FM_ALG_SSF33            0x00000000
+#define FM_ALG_SCB2_S           0x00000001   /* SCB2 special */
+#define FM_ALG_SCB2_G           0x00000002   /* SCB2 general */
+#define FM_ALG_SM1              FM_ALG_SCB2_G
+#define FM_ALG_SM6              FM_ALG_SCB2_S
+#define FM_ALG_3DES             0x00000003
+#define FM_ALG_AES              0x00000004
+#define FM_ALG_DES              0x00000005
+#define FM_ALG_RC2              0x00000006
+#define FM_ALG_RC4              0x00000007
+#define FM_ALG_SM4              0x00000008
+
+/* asymmetry */
+#define FM_ALG_RSA1024          0x00000000
+#define FM_ALG_RSA2048          0x00000001
+#define FM_ALG_RSA4096          0x00000002
+#define FM_ALG_SM2_1            0x00000003
+#define FM_ALG_SM2_2            0x00000004
+#define FM_ALG_SM2_3            0x00000005
+/* hash */
+#define FM_ALG_MD2              0x00000000
+#define FM_ALG_MD4              0x00000001
+#define FM_ALG_MD5              0x00000002
+#define FM_ALG_SHA1             0x00000003
+#define FM_ALG_SHA256           0x00000004
+#define FM_ALG_SHA384           0x00000005
+#define FM_ALG_SHA512           0x00000006
+#define FM_ALG_SM3              0x00000007
+
+/******************** change byte order macro *******************/
+#define FM_SWAP16(s) (((s)&0xff)<<8|((s)&0xff00)>>8)
+#define FM_SWAP32(u) (((u)&0xff)<<24|((u)&0xff00)<<8|((u)&0xff0000)>>8|((u)&0xff000000)>>24)
+#ifdef FM_LITTLE_ENDIAN
+    #define FM_H2NS(s) FM_SWAP16(s)
+    #define FM_N2HS(s) FM_SWAP16(s)
+    #define FM_H2NL(u) FM_SWAP32(u)
+    #define FM_N2HL(u) FM_SWAP32(u)
+#else
+    #define FM_H2NS(s)  (s)
+    #define FM_N2HS(s)  (s)
+    #define FM_H2NL(u)  (u)
+    #define FM_N2HL(u)  (u)
+#endif
+
+/**** error code: low 11 bit of api return value 0x000-0x7ff ****/
+/* get error code macro */
+#define FME_GETERR(e)       ((e) & 0x7ff)
+/* general error        0x000 - 0x07f */ 
+#define FME_OK                  0x000      /* ok */
+#define FME_ERR                 0x001      /* fail */
+#define FME_POK                 0x002      /* part ok */
+#define FME_UNKNOWN             0x003      /* unknown error */
+#define FME_NOTSUPPORT          0x004      /* not support */
+#define FME_PARA                0x005      /* error parameter */
+#define FME_NORIGHT             0x006      /* error right */
+#define FME_BUSY                0x007      /* device busy */
+#define FME_TIMEOUT             0x008      /* operation timeout */
+#define FME_NOMEM               0x009      /* no mem */
+#define FME_NORES               0x00a      /* no resouce */
+#define FME_COMMERR             0x00b      /* communication error */
+#define FME_ACCESSREG           0x00c      /* register access error */
+#define FME_STACKOVER           0x00d      /* stack is overflow */
+#define FME_DEVINUSE            0x00e      /* device is used now */
+#define FME_SESEXCEED           0x00f      /* open session is out of range */
+#define FME_DMAREADERR          0x010      /* dma read error */
+#define FME_DMAWRITEERR         0x011      /* dma write error */
+#define FME_CREATESYNCERR       0x012      /* create sync objcect error */
+#define FME_GETSYNCERR          0x013      /* get sync objcect error */
+#define FME_RELEASESYNCERR      0x014      /* release sync objcect error */
+#define FME_DATALENERR          0x015      /* data length error */
+#define FME_KEYLENERR           0x016      /* key length error or not support */
+
+
+/* atuo test error      0x080 - 0x09f */
+#define FME_AT_OK               0x080      /* auto test success */
+#define FME_AT_USB              0X081      /* usb test error */
+#define FME_AT_RANDOM           0X082      /* random test error */
+#define FME_AT_SM1              0X083      /* sm1/scb2 alg test error */
+#define FME_AT_PROGCHECK        0X084      /* program integrality test error */
+#define FME_AT_STARTING         0X085      /* device is starting  */
+#define FME_AT_SM2              0X086      /* sm2 alg init error */
+
+/* common alg error     0x0a0 - 0x0ff */
+#define FME_KEYNOTEXIST         0x0a0      /* key is not exist */
+#define FME_KEYNOFREE           0x0a1      /* no free key handle */
+#define FME_KEYEXCEED           0x0a2      /* key handle is out of range */
+#define FME_STEPERR             0x0a3      /* alg step err(init/update/final) */
+/* sym err              0x100 - 0x17f */
+#define FME_IVLENERR            0x100      /* iv length error*/
+
+/* asym err             0x180 - 0x1ff */
+#define FME_ECC_NOTINIT         0x180      /* ECC not init */
+#define FME_ECC_PUBKEYERR       0x181      /* ECC pubkey error */
+#define FME_ECC_PRIKEYERR       0x182      /* ECC prikey error */
+#define FME_ECC_SIGNERR         0x183      /* ECC sign error */
+#define FME_ECC_VERIFYERR       0x184      /* ECC verify error */
+#define FME_ECC_ENCRYPTERR      0x185      /* ECC encrypt error */
+#define FME_ECC_DECRYPTERR      0x186      /* ECC decrypt error */
+
+
+/* hash err             0x200 - 0x23f */
+#define FME_SM3_IDLENERR        0x200      /* SM3 user'ID length is out of range */
+
+/* file system err      0x240 - 0x27f */
+#define FME_FILE_NOTINIT        0x240      /* file system is not init */
+#define FME_FILE_DIRDEPTH       0x241      /* dir nested too deep */
+#define FME_FILE_DIRNOTEXIST    0x242      /* dir is not exist */
+#define FME_FILE_FILENOTEXIST   0x243      /* file is not exist */
+#define FME_FILE_DIREXIST       0x244      /* dir has already exist */
+#define FME_FILE_FILEEXIST      0x245      /* file has already exist */
+#define FME_FILE_DIRNUMEXCEED   0x246      /* dir number is out of range */
+#define FME_FILE_FILENUMEXCEED  0x247      /* file number is out of range */
+#define FME_FILE_NOSPACE        0x248      /* file space is not enough */
+#define FME_FILE_OPRANGE        0x249      /* file operation is out of range */
+#define FME_FLASH_TIMEOUT       0x260      /* flash operation is timeout */
+#define FME_FLASH_WRITEERR      0x261      /* flash write error */
+#define FME_FLASH_READERR       0x262      /* flash read error */
+#define FME_FLASH_OPRANGE       0x263      /* flash operation is out of range */
+#define FME_EE_TIMEOUT          0x264      /* eeprom operation is timeout */
+#define FME_EE_WRITEERR         0x265      /* eeprom write error  */
+#define FME_EE_READERR          0x266      /* eeprom read error */
+#define FME_EE_OPRANGE          0x267      /* eeprom operation is out of range */
+/* user err             0x280 - 0x2bf  */
+#define FME_USER_NOTEXIST       0x280      /* user is not exist */
+#define FME_USER_EXIST          0x281      /* user has already exist */
+#define FME_USER_EXCEED         0x282      /* user number is out of range */
+#define FME_USER_PINERR         0x283      /* user pin err */
+#define FME_USER_STEPERR        0x284      /* backup step err */
+#define FME_USER_OPENDEVERR     0x285      /* open user dev err */
+#define FME_USER_GETDEVINFOERR  0x286      /* get user dev info err */
+#define FME_USER_WRITEDEVERR    0x287      /* write user dev mem err */
+#define FME_USER_READDEVERR     0x288      /* read user dev mem err */
+#define FME_USER_NOLOG          0x289      /* user is not login */
+
+/* network err             0x2c0 - 0x2ff  */
+#define FME_NET_NOCONNECT					0x2c0				/*can not get connect */
+#define FME_NET_SENDERR						0x2c1   		/*send data error */
+#define FME_NET_RECVERR						0x2c2   		/*receive data error */
+#define FME_NET_SOCKETPOOLFREEERR	0x2c3  			/*free socket pool error */
+
+/* debug err            0x2c0 - 0x2ff  */
+
+/********************* config releated macro ********************/
+/* cpu and os platform type */
+#define FMCFG_OS_WINDOWS
+//#define FMCFG_OS_LINUX
+//#define FMCFG_OS_DSP
+//#define FMCFG_OS_COS
+
+/* product type */
+//#define FMCFG_TYPE_SJK0809  /* PCI Express Crypto PCI Card */
+#define FMCFG_TYPE_SJK0810  /* PCI Crypto PCI Card */
+//#define FMCFG_TYPE_SJK0918  /* USB Key */
+//#define FMCFG_TYPE_SJJ1002  /* SCSI Key */
+
+/* compile version */
+//#define FMCFG_VER_DEBUG     /* debug version */
+#define FMCFG_VER_RELEASE   /* release version */
+
+
+/*************************** dev type ***************************/
+#define FM_DEV_TYPE_SJK0809   1
+#define FM_DEV_TYPE_SJK0810   2
+#define FM_DEV_TYPE_SJK0918   3
+#define FM_DEV_TYPE_SJK1150   4
+#define FM_DEV_TYPE_SJJ1002   5
+#define FM_DEV_TYPE_SSX1104   6
+
+/********************** open device flag ************************/
+#define FM_OPEN_EXCLUSIVE     0x00000001  /* exclusive open device */
+#define FM_OPEN_MULTITHREAD   0x00000002  /* device support multi thread. only used by user api */
+#define FM_OPEN_MULTIPROCESS  0x00000004  /* device support multi process only used by user api */
+#define FM_OPEN_INT           0x00000008  /* host and device communicate by interrupt. only used by kernel api */
+#define FM_OPEN_SCH           0x00000010  /* host and device communicate by poll. only used by kernel api  */
+#define FM_OPEN_SHARE         0x00000020  /* share open device */
+#define FM_OPEN_ASYNC         0x00000040  /* async call mode. only used by kernel api  */
+#define FM_OPEN_FMCS          0x00000080  /* only for fisherman crypto server */
+
+/************************* device info **************************/
+#define FM_DEVINFO_ISSUER_LEN   16
+#define FM_DEVINFO_DEVICE_LEN   16
+#define FM_DEVINFO_SERIAL_LEN   16
+
+typedef struct tagDeviceInfoSt
+{
+    FM_U32 u32State;                                /* 设备状态 */
+                                                    // 其他，未初始化
+    FM_U8  au8IssuerName[FM_DEVINFO_ISSUER_LEN];    /* 生产厂商名称 */
+    FM_U8  au8DeviceName[FM_DEVINFO_DEVICE_LEN];    /* 型号 */
+    FM_U8  au8DeviceSerial[FM_DEVINFO_SERIAL_LEN];  /* 编号 */
+    FM_U32 u32DeviceVersion;                        /* 内部软件的版本号 */
+    FM_U32 au32SymAlgMask[4];                       /* 所支持的对称算法 */
+    FM_U32 au32AsymAlgMask[4];                      /* 所支持的非对称的算法 */
+    FM_U32 au32HashAlgMask[4];                      /* 所支持的杂凑算法 */
+    FM_U32 au32SymKeyNum[4];                        /* 对称密钥数目 低16位是永久密钥数目，高16位是临时密钥数目 */
+    FM_U32 au32AsymKeyNum[4];                       /* 非对称密钥数目 低16位是永久密钥数目，高16位是临时密钥数目  */
+    FM_U32 u32FileSize;                             /* 支持文件存储空间 */
+    FM_U16 u16DirNum;                               /* 支持目录的数目 */
+    FM_U16 u16FileNum;                              /* 支持文件的数目 */
+}FM_DEV_INFO, *PFM_DEV_INFO;
+
+
+/************************* key handle ***************************/
+#define FM_HKEY_TO_HOST     (FM_HANDLE)0x01ffffff  /* key is not storage in dev */ 
+#define FM_HKEY_FROM_HOST   (FM_HANDLE)0x02ffffff  /* use host import temp key */
+#define FM_HKEY_BYDEV_PERM  (FM_HANDLE)0x03ffffff  /* key handle created by dev, permanent storage in device */ 
+#define FM_HKEY_BYDEV_TEMP  (FM_HANDLE)0x83ffffff  /* key handle created by dev, temporary storage in device */ 
+#define FM_HKEY_MEM_MASK               0x80000000  /* the high bit equal to 1, temporary storage in device */
+
+/***************************** RSA ******************************/
+/* len */
+#define FM_RSA_MAX_BITS     2048
+#define FM_RSA_MAX_LEN      256
+#define FM_RSA_MAX_PLEN     128
+/* public Key size=516byte */
+typedef struct tagRSAPublicKeySt
+{
+     FM_U32 bits;                      /* modulus bit length */
+     FM_U8 m[FM_RSA_MAX_LEN];          /* modulus N, N=P*Q */
+     FM_U8 e[FM_RSA_MAX_LEN];          /* public exponent E */
+}FM_RSA_PublicKey, *PFM_RSA_PublicKey;
+/* private Key size=1412byte */
+typedef struct tagRSAPrivateKeySt
+{
+     FM_U32 bits;                      /* modulus bit length */
+     FM_U8 m[FM_RSA_MAX_LEN];          /* modulus N, N=P*Q */
+     FM_U8 e[FM_RSA_MAX_LEN];          /* public exponent E */
+     FM_U8 d[FM_RSA_MAX_LEN];          /* private exponent D, D=(E^-1)mod(P-1)(Q-1), now not use */
+     FM_U8 prime[2][FM_RSA_MAX_PLEN];  /* prime P and Q, P>Q */
+     FM_U8 pexp[2][FM_RSA_MAX_PLEN];   /* Dp,Dq, Dp=D mod(P-1),Dq=D mod(Q-1) */
+     FM_U8 coef[FM_RSA_MAX_PLEN];      /* Q^-1 mod P  */
+}FM_RSA_PrivateKey, *PFM_RSA_PrivateKey; 
+
+/***************************** ECC ******************************/
+/* len */
+#define FM_ECC_MAX_BITS      256
+#define FM_ECC_MAX_LEN       ((FM_ECC_MAX_BITS+7)/8)
+#define FM_ECC_MAX_INBUF_LEN 160
+/* public Key */
+typedef struct tag_ECC_PublicKey_St
+{
+     FM_U32 bits;                      /* modulus bit length */
+     FM_U8 x[FM_ECC_MAX_LEN];          /* x */
+     FM_U8 y[FM_ECC_MAX_LEN];          /* y */     
+}FM_ECC_PublicKey, *PFM_ECC_PublicKey;
+/* private Key */
+typedef struct tag_ECC_PrivateKey_St
+{
+     FM_U32 bits;                      /* modulus bit length */
+     FM_U8  D[FM_ECC_MAX_LEN];         /* PrivateKey */     
+}FM_ECC_PrivateKey, *PFM_ECC_PrivateKey; 
+
+/* ECC Signature */
+typedef struct tag_ECC_Signature_St
+{
+     FM_U8 r[FM_ECC_MAX_LEN];          /* r */
+     FM_U8 s[FM_ECC_MAX_LEN];          /* s */     
+}FM_ECC_Signature, *PFM_ECC_Signature;
+
+typedef struct tag_ECC_Cipher_st
+{
+    FM_U32 Clength;            /*加密数据长度*/
+    FM_U8  x[FM_ECC_MAX_LEN];  /*与y组成椭圆曲线上的点(x,y)*/
+    FM_U8  y[FM_ECC_MAX_LEN];  /*与x组成椭圆曲线上的点(x,y)*/
+    FM_U8  C[FM_ECC_MAX_INBUF_LEN];             /*加密数据*/
+    FM_U8  M[FM_ECC_MAX_LEN];  /*预留,用于支持带MAC输出的ECC算法*/
+}FM_ECC_Cipher, *PFM_ECC_Cipher;
+
+/* ECC curve data */
+typedef struct tag_ECC_curve_data_st
+{
+    FM_U8  p[FM_ECC_MAX_LEN];   /*素数P*/
+    FM_U8  a[FM_ECC_MAX_LEN];   /*参数a*/
+    FM_U8  b[FM_ECC_MAX_LEN];   /*参数b*/
+    FM_U8  x[FM_ECC_MAX_LEN];   /**/
+    FM_U8  y[FM_ECC_MAX_LEN];   /**/
+    FM_U8  N[FM_ECC_MAX_LEN];   /**/
+    FM_U32 bits;
+}FM_ECC_CURVE_DATA, *PFM_ECC_CURVE_DATA;
+
+typedef struct
+{
+    FM_U32 h0,h1,h2,h3,h4;
+    FM_U32 Nl,Nh;
+    FM_U32 data[16];
+    FM_U32 num;
+    FM_U32 len;
+    FM_U8  hash[32];
+}FM_CPC_SHA1_CTX, *PFM_CPC_SHA1_CTX;
+
+typedef struct
+{
+    FM_U8  u8TempData[64];
+    FM_U32 u32TempDataLen;
+    FM_U32 u32IV[8];
+    FM_U32 Nl,Nh;
+    FM_U32 u32DateLen;
+    FM_U8  u8ID[128];
+    FM_U32 u32IDLen;
+    FM_ECC_PublicKey EccPubkey;
+}FM_CPC_SM3_CTX, *PFM_CPC_SM3_CTX;
+
+/***************************** pin ******************************/
+/* len */
+#define FM_PIN_MAXLEN         16  /* pin max length */
+#define FM_PIN_MINLEN         6   /* pin min length */
+#define FM_PIN_MAXRETRY       6   /* max retry times */
+/* pin type */
+#define FM_PIN_ADMIN          1
+#define FM_PIN_OPER           2
+/* change type */
+#define FM_PIN_CHANGEOPER     1   /* change operator pin */
+#define FM_PIN_CHANGEADMIN    2   /* change administrator pin */
+#define FM_PIN_UNBLOCKOPER    3   /* unblock operator pin */
+
+/************************* authenticate *************************/
+#define FM_INTAUTH            1   /* internal authenticate */
+#define FM_EXTAHTH            2   /* external authenticate */
+
+/*********************** get/set info flag **********************/
+/*  */
+#define FM_INFO_STATE            0x0001
+/* dev info */
+#define FM_INFO_VENDOR           0x0101
+#define FM_INFO_DEVTYPE          0x0102
+#define FM_INFO_DEVNAME          0x0103
+#define FM_INFO_SERIAL           0x0104
+/* dev version */
+#define FM_INFO_HWVER            0x0201
+#define FM_INFO_FWVER            0x0202
+#define FM_INFO_DRVVER           0x0203
+#define FM_INFO_APIVER           0x0204
+/* dev alg */
+#define FM_INFO_SYMALG           0x0301
+#define FM_INFO_ASYMALG          0x0302
+#define FM_INFO_HASHALG          0x0303
+/* sym alg key */
+#define FM_INFO_SYMKEY_TEMP      0x0401
+#define FM_INFO_SYMKEY_PERM      0x0402
+#define FM_INFO_SYMKEYSM1_TEMP   0x0403
+#define FM_INFO_SYMKEYSM1_PERM   0x0404
+#define FM_INFO_SYMKEYSM6_TEMP   0x0405
+#define FM_INFO_SYMKEYSM6_PERM   0x0406
+#define FM_INFO_SYMKEYSSF33_TEMP 0x0407
+#define FM_INFO_SYMKEYSSF33_PERM 0x0408
+/* asym alg key */
+#define FM_INFO_ASYMKEY_TEMP     0x0501
+#define FM_INFO_ASYMKEY_PERM     0x0502
+#define FM_INFO_ASYMKEYRSA_TEMP  0x0503
+#define FM_INFO_ASYMKEYRSA_PERM  0x0504
+#define FM_INFO_ASYMKEYECC_TEMP  0x0505
+#define FM_INFO_ASYMKEYECC_PERM  0x0506
+
+/* file */
+#define FM_INFO_FILESYSSIZE      0x0601   /* file systme all space */
+#define FM_INFO_FILESIZE         0x0602   /* one file size */
+#define FM_INFO_DIRNUM           0x0603
+#define FM_INFO_FILENUM          0x0604
+/* user */
+
+/* cert */
+#define FM_CERT_ENC       1
+#define FM_CERT_SIGN      2
+#define FM_KEYNUM_ENC     3
+#define FM_KEYNUM_SIGN    4
+
+#define FM_MIN(a,b) ((a) > (b) ?  (b) : (a))
+#define FM_MAX(a,b) ((a) > (b) ?  (a) : (b))
+
+/* waitfor event */ 
+#define FM_WAITFOR 0
+#define FM_SETEVENT 1
+#define FM_RESETEVENT 2 
+
+#ifdef  __cplusplus
+    }
+#endif  /* #ifdef  __cplusplus */
+
+#endif  /* #ifndef FM_DEF_H */
+

Property changes on: openssl-1.0.1e/include/openssl/sm/fm_def.h
___________________________________________________________________
Added: svn:executable
   + *

Index: openssl-1.0.1e/include/openssl/sm/sm_pub.h
===================================================================
--- openssl-1.0.1e/include/openssl/sm/sm_pub.h	(revision 0)
+++ openssl-1.0.1e/include/openssl/sm/sm_pub.h	(revision 0)
@@ -0,0 +1,78 @@
+#ifndef _SM_PUBLIC_H_
+#define _SM_PUBLIC_H_
+
+enum{
+	vendor_fm=1,
+
+	max_verdor,
+};
+
+enum fm_type_e {
+	dev_type_pci_1_2 = 1,
+	dev_type_pci_2_0,
+	dev_type_pcie_1_0,
+	dev_type_pcie_2_0,
+
+	max_card_type,
+};
+
+/* TODO: OS_RUNNING_DIR instead of '/secgate' */
+#define SM_CONF_FILE	"/secgate/app/openssl/plugins/smcard.conf"
+
+#define FM_API_LIB	"/secgate/app/openssl/plugins/fmcard/libfmapiv100.so"
+
+#define SMCARD_VENDOR	"vendor"
+#define SMCARD_TYPE	"type"
+
+/* return: 0 - not exist, others - exist */
+static inline int does_smcard_exist(void)
+{
+	char cmd[128];
+
+	sprintf(cmd, "/bin/grep \"%s = 0\" %s >/dev/null", SMCARD_VENDOR, SM_CONF_FILE);
+	return system(cmd);
+}
+
+static inline int get_smcard_info(int *vendor, int *dev_type)
+{
+	FILE *fp = NULL;
+	char buf[128]={0}, cmd[128];
+
+	/* read card vendor from hw config file */
+	sprintf(cmd, "/bin/grep \"%s\" %s | awk {'print $3'}", SMCARD_VENDOR, SM_CONF_FILE);
+	if ((fp = popen(cmd, "r")) == NULL) {
+		return -1;
+	}
+	memset(buf, 0, sizeof(buf));
+	fgets(buf, sizeof(buf), fp);
+	pclose(fp);
+
+	*vendor = atoi(buf);
+	if(*vendor == 0) {
+		return -1;
+	}
+
+	/* read card subtype from hw config file */
+	sprintf(cmd, "/bin/grep \"%s\" %s | awk {'print $3'}", SMCARD_TYPE, SM_CONF_FILE);
+	if ((fp = popen(cmd, "r")) == NULL) {
+		return -1;
+	}
+	memset(buf, 0, sizeof(buf));
+	fgets(buf, sizeof(buf), fp);
+	pclose(fp);
+
+	*dev_type = atoi(buf);
+	return 0;
+}
+
+static inline void save_smcard_info(int vendor, int type)
+{
+	char cmd[128];
+
+	snprintf(cmd, sizeof(cmd), "echo \"%s = %d\" > \"%s\"", SMCARD_VENDOR, vendor, SM_CONF_FILE);
+	system(cmd);
+	snprintf(cmd, sizeof(cmd), "echo \"%s = %d\" >> \"%s\"", SMCARD_TYPE, type, SM_CONF_FILE);
+	system(cmd);
+}
+
+#endif
