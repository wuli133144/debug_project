Index: openssl-1.0.1e/crypto/ec/ec_pmeth.c
===================================================================
--- openssl-1.0.1e/crypto/ec/ec_pmeth.c	(revision 22779)
+++ openssl-1.0.1e/crypto/ec/ec_pmeth.c	(working copy)
@@ -61,6 +61,7 @@
 #include <openssl/x509.h>
 #include <openssl/ec.h>
 #include <openssl/ecdsa.h>
+#include <openssl/sm2.h>
 #include <openssl/evp.h>
 #include "evp_locl.h"
 
@@ -178,6 +179,64 @@
 	return ret;
 	}
 
+static int pkey_ec_encrypt(EVP_PKEY_CTX *ctx,
+					unsigned char *out, size_t *outlen,
+					const unsigned char *in, size_t inlen)
+	{
+	int ret;
+	EC_KEY *ec = ctx->pkey->pkey.ec;
+
+	if (EC_GROUP_get_curve_name(EC_KEY_get0_group(ec)) != NID_sm2) {
+		EVPerr(EVP_F_EVP_PKEY_ENCRYPT,
+			EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+		return -2;
+	}
+
+	ret = SM2_crpt_size(ec, inlen, 1);
+	if (!out) {
+		*outlen = ret;
+		return 1;
+	} else if(*outlen < (size_t)ret) {
+		ECerr(EC_F_PKEY_EC_ENCRYPT, EC_R_BUFFER_TOO_SMALL);
+		return 0;
+	}
+
+	ret = SM2_encrypt(inlen, in, out, ec);
+	if (ret < 0)
+		return ret;
+	*outlen = ret;
+	return 1;
+	}
+
+static int pkey_ec_decrypt(EVP_PKEY_CTX *ctx,
+					unsigned char *out, size_t *outlen,
+					const unsigned char *in, size_t inlen)
+	{
+	int ret;
+	EC_KEY *ec = ctx->pkey->pkey.ec;
+
+	if (EC_GROUP_get_curve_name(EC_KEY_get0_group(ec)) != NID_sm2) {
+		EVPerr(EVP_F_EVP_PKEY_ENCRYPT,
+			EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+		return -2;
+	}
+
+	ret = SM2_crpt_size(ec, inlen, 0);
+	if (!out) {
+		*outlen = ret;
+		return 1;
+	} else if(*outlen < (size_t)ret) {
+		ECerr(EC_F_PKEY_EC_DECRYPT, EC_R_BUFFER_TOO_SMALL);
+		return 0;
+	}
+
+	ret = SM2_decrypt(inlen, in, out, ec);
+	if (ret < 0)
+		return ret;
+	*outlen = ret;
+	return 1;
+	}
+
 static int pkey_ec_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen)
 	{
 	int ret;
@@ -340,9 +399,11 @@
 
 	0,0,0,0,
 
-	0,0,
+	0,
+	pkey_ec_encrypt,
 
-	0,0,
+	0,
+	pkey_ec_decrypt,
 
 	0,
 	pkey_ec_derive,
Index: openssl-1.0.1e/crypto/ec/ec.h
===================================================================
--- openssl-1.0.1e/crypto/ec/ec.h	(revision 22779)
+++ openssl-1.0.1e/crypto/ec/ec.h	(working copy)
@@ -1107,6 +1107,8 @@
 #define EC_F_OLD_EC_PRIV_DECODE				 222
 #define EC_F_PKEY_EC_CTRL				 197
 #define EC_F_PKEY_EC_CTRL_STR				 198
+#define EC_F_PKEY_EC_ENCRYPT				 238
+#define EC_F_PKEY_EC_DECRYPT				 239
 #define EC_F_PKEY_EC_DERIVE				 217
 #define EC_F_PKEY_EC_KEYGEN				 199
 #define EC_F_PKEY_EC_PARAMGEN				 219
Index: openssl-1.0.1e/crypto/sm2/sm2_ossl.c
===================================================================
--- openssl-1.0.1e/crypto/sm2/sm2_ossl.c	(revision 22779)
+++ openssl-1.0.1e/crypto/sm2/sm2_ossl.c	(working copy)
@@ -598,13 +598,13 @@
 	return ret;
 }
 
-int sm2_do_encrypt(int flen, const unsigned char *from,
+static int sm2_do_encrypt(int flen, const unsigned char *from,
 	unsigned char *to, EC_KEY *eckey)
 {
 	return sm2_do_encrypt_ex(flen, from, to, eckey, NULL);
 }
 
-int sm2_do_decrypt(int flen, const unsigned char *from,
+static int sm2_do_decrypt(int flen, const unsigned char *from,
 	unsigned char *to, EC_KEY *eckey)
 {
 	const EC_GROUP *group;
@@ -615,7 +615,7 @@
 	BIGNUM *x = BN_new();
 	BIGNUM *y = BN_new();
 	BIGNUM *h = BN_new();
-	EC_POINT *C1, *S;
+	EC_POINT *C1 = NULL, *S = NULL;
 
 	unsigned int i = 0;
 	unsigned char *t = NULL, *temp = NULL;
Index: openssl-1.0.1e/crypto/sm2/sm2.h
===================================================================
--- openssl-1.0.1e/crypto/sm2/sm2.h	(revision 22779)
+++ openssl-1.0.1e/crypto/sm2/sm2.h	(working copy)
@@ -28,9 +28,32 @@
 } SM2_SIG;
 
 /* This four functions are the same with ECDSA */
+
+/** Allocates and initialize a SM2_SIG structure
+ *  \return pointer to a SM2_SIG structure or NULL if an error occurred
+ */
 SM2_SIG *SM2_SIG_new(void);
+
+/** frees a SM2_SIG structure
+ *  \param  sig  pointer to the SM2_SIG structure
+ */
 void	  SM2_SIG_free(SM2_SIG *sig);
+
+/** DER encode content of ECDSA_SIG object (note: this function modifies *pp
+ *  (*pp += length of the DER encoded signature)).
+ *  \param  sig  pointer to the ECDSA_SIG object
+ *  \param  pp   pointer to a unsigned char pointer for the output or NULL
+ *  \return the length of the DER encoded ECDSA_SIG object or 0 
+ */
 int	  i2d_SM2_SIG(const SM2_SIG *sig, unsigned char **pp);
+
+/** Decodes a DER encoded ECDSA signature (note: this function changes *pp
+ *  (*pp += len)). 
+ *  \param  sig  pointer to ECDSA_SIG pointer (may be NULL)
+ *  \param  pp   memory buffer with the DER encoded signature
+ *  \param  len  length of the buffer
+ *  \return pointer to the decoded ECDSA_SIG structure (or NULL)
+ */
 SM2_SIG *d2i_SM2_SIG(SM2_SIG **sig, const unsigned char **pp, long len);
 
 int SM2_sign_pre_process(const EC_KEY *ec, unsigned char *Z);
@@ -94,6 +117,14 @@
  */
 int	  SM2_size(const EC_KEY *eckey);
 
+/** Returns the crypto length
+ *  \param  eckey  EC_KEY object
+ *  \param  ilen     length of in data
+ *  \param  enc     encrypt (1) or decrypt (0)
+ *  \return numbers of bytes required for encrypt or decrypt which depends on 'enc'
+ */
+int SM2_crpt_size(const EC_KEY *eckey, int ilen, int enc);
+
 /** Precompute parts of the signing operation
  *  \param  eckey  EC_KEY object containing a private EC key
  *  \param  ctx    BN_CTX object (optional)
Index: openssl-1.0.1e/crypto/sm2/sm2_lib.c
===================================================================
--- openssl-1.0.1e/crypto/sm2/sm2_lib.c	(revision 22779)
+++ openssl-1.0.1e/crypto/sm2/sm2_lib.c	(working copy)
@@ -5,6 +5,9 @@
 #ifndef OPENSSL_NO_ENGINE
 #include <openssl/engine.h>
 #endif
+#ifndef OPENSSL_NO_SM3
+#include <openssl/sm3.h>
+#endif
 #include <openssl/err.h>
 #include <openssl/bn.h>
 #ifdef OPENSSL_FIPS
@@ -197,7 +200,19 @@
 	return(ret);
 }
 
+int SM2_crpt_size(const EC_KEY *r, int ilen, int enc)
+{
+	const EC_GROUP *group = EC_KEY_get0_group(r);
+	int ret, xylen = EC_GROUP_get_degree(group) / 8;
 
+	if (enc)
+		ret = 1 + xylen + xylen + ilen + SM3_DIGEST_LENGTH;
+	else
+		ret = ilen - 1 - xylen - xylen - SM3_DIGEST_LENGTH;
+	return (ret);
+}
+
+
 int SM2_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
 	     CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
 {
